<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inventory - CRM</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #f5f5f5;
            color: #333;
        }

        /* Navigation */
        .nav {
            background: #fff;
            border-bottom: 1px solid #e0e0e0;
            padding: 12px 24px;
            display: flex;
            align-items: center;
            gap: 24px;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .nav-title {
            font-size: 18px;
            font-weight: 600;
            color: #1a73e8;
        }

        .nav-tabs {
            display: flex;
            gap: 8px;
        }

        .nav-tab {
            padding: 8px 16px;
            border-radius: 20px;
            text-decoration: none;
            color: #5f6368;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .nav-tab:hover {
            background: #f1f3f4;
        }

        .nav-tab.active {
            background: #e8f0fe;
            color: #1a73e8;
        }

        /* Toolbar */
        .toolbar {
            background: #fff;
            border-bottom: 1px solid #e0e0e0;
            padding: 12px 24px;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #1a73e8;
            color: #fff;
        }

        .btn-primary:hover {
            background: #1557b0;
        }

        .btn-secondary {
            background: #fff;
            color: #5f6368;
            border: 1px solid #dadce0;
        }

        .btn-secondary:hover {
            background: #f1f3f4;
        }

        .btn-danger {
            background: #ea4335;
            color: #fff;
        }

        .btn-danger:hover {
            background: #c5221f;
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 13px;
        }

        /* Math toolbar */
        .math-toolbar {
            display: none;
            position: sticky;
            top: 52px;
            z-index: 99;
            background: #1a73e8;
            color: white;
            padding: 10px 24px;
            align-items: center;
            gap: 12px;
            animation: slideDown 0.2s ease;
        }

        .math-toolbar.show {
            display: flex;
        }

        @keyframes slideDown {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .math-input {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            width: 180px;
            font-family: monospace;
        }

        .math-input:focus {
            outline: 2px solid white;
        }

        /* Selected cells */
        .cell.math-selected {
            background: #e8f0fe !important;
            outline: 2px solid #1a73e8;
            outline-offset: -2px;
        }

        .filter-select {
            padding: 8px 12px;
            border: 1px solid #dadce0;
            border-radius: 4px;
            font-size: 14px;
            background: #fff;
        }

        .search-input {
            padding: 8px 12px;
            border: 1px solid #dadce0;
            border-radius: 4px;
            font-size: 14px;
            width: 200px;
        }

        .spacer {
            flex: 1;
        }

        .selection-info {
            font-size: 13px;
            color: #5f6368;
        }

        /* Table container */
        .table-container {
            background: #fff;
            margin: 0;
            overflow-x: auto;
        }

        /* Spreadsheet-style table */
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        th {
            background: #f8f9fa;
            padding: 8px 12px;
            text-align: left;
            font-weight: 500;
            color: #5f6368;
            border-bottom: 1px solid #e0e0e0;
            position: sticky;
            top: 0;
            white-space: nowrap;
            user-select: none;
        }

        th.sortable {
            cursor: pointer;
            position: relative;
            padding-right: 20px;
        }

        th.sortable:hover {
            background: #e8eaed;
        }

        th.sortable::after {
            content: 'â‡…';
            position: absolute;
            right: 4px;
            opacity: 0.3;
            font-size: 10px;
        }

        th.sortable.sorted-asc::after {
            content: 'â†‘';
            opacity: 1;
        }

        th.sortable.sorted-desc::after {
            content: 'â†“';
            opacity: 1;
        }

        td {
            padding: 0;
            border-bottom: 1px solid #e8eaed;
            border-right: 1px solid #e8eaed;
        }

        td:last-child {
            border-right: none;
        }

        tr:hover td {
            background: #f8f9fa;
        }

        tr.sold td {
            background: #e6f4ea;
        }

        tr.sold:hover td {
            background: #ceead6;
        }

        tr.unsold td {
            background: #fef7e0;
        }

        tr.unsold:hover td {
            background: #feefc3;
        }

        tr.posted td {
            background: #ffcc80;
        }

        tr.posted:hover td {
            background: #ffb74d;
        }

        tr.selected td {
            background: #e8f0fe !important;
        }

        /* Editable cells */
        .cell {
            padding: 8px 12px;
            min-height: 36px;
            cursor: text;
        }

        .cell:focus {
            outline: 2px solid #1a73e8;
            outline-offset: -2px;
            background: #fff !important;
        }

        .cell-checkbox {
            width: 40px;
            text-align: center;
        }

        .cell-checkbox input {
            cursor: pointer;
        }

        .cell-number {
            text-align: right;
            font-variant-numeric: tabular-nums;
        }

        .cell-date {
            min-width: 100px;
        }

        .cell-profit {
            font-weight: 500;
        }

        .positive {
            color: #137333;
        }

        .negative {
            color: #c5221f;
        }

        /* Row number */
        .row-num {
            color: #5f6368;
            font-size: 12px;
            text-align: center;
            width: 40px;
            background: #f8f9fa;
        }

        /* Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: #fff;
            border-radius: 8px;
            padding: 24px;
            width: 100%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            color: #5f6368;
            margin-bottom: 6px;
        }

        .form-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #dadce0;
            border-radius: 4px;
            font-size: 14px;
        }

        .form-input:focus {
            outline: none;
            border-color: #1a73e8;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            margin-top: 24px;
        }

        /* Summary bar */
        .summary-bar {
            background: #fff;
            border-top: 1px solid #e0e0e0;
            padding: 12px 24px;
            display: flex;
            gap: 32px;
            font-size: 13px;
            position: sticky;
            bottom: 0;
        }

        .summary-item {
            display: flex;
            gap: 8px;
        }

        .summary-label {
            color: #5f6368;
        }

        .summary-value {
            font-weight: 600;
        }

        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: #323232;
            color: #fff;
            padding: 12px 24px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 1001;
            display: none;
        }

        .toast.show {
            display: block;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-50%) translateY(20px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        /* Pagination */
        .pagination-bar {
            background: #fff;
            border-top: 1px solid #e0e0e0;
            padding: 12px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
        }

        .pagination-info {
            color: #5f6368;
        }

        .pagination-controls {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .page-info {
            color: #5f6368;
        }

        .per-page-select select {
            padding: 6px 10px;
            border: 1px solid #dadce0;
            border-radius: 4px;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <nav class="nav">
        <div class="nav-title">ReLoomer CRM</div>
        <div class="nav-tabs">
            <a href="/overview" class="nav-tab">Overview</a>
            <a href="/inventory" class="nav-tab active">Inventory</a>
            <a href="/expenses" class="nav-tab">Expenses</a>
            <a href="/listings" class="nav-tab">Listings</a>
        </div>
    </nav>

    <!-- Math operations toolbar (appears when cells selected) -->
    <div class="math-toolbar" id="mathToolbar">
        <span id="mathSelectedCount">0 cells selected</span>
        <input type="text" id="mathExpression" placeholder="e.g. /5.1 or *0.2 or +10" class="math-input">
        <button class="btn btn-primary btn-sm" onclick="applyMathOperation()">Apply</button>
        <button class="btn btn-secondary btn-sm" onclick="clearCellSelection()">Clear</button>
    </div>

    <div class="toolbar">
        <button class="btn btn-primary" onclick="openBulkAddModal()">+ Add Batch</button>
        <button class="btn btn-secondary" onclick="addSingleRow()">+ Add Row</button>
        <button class="btn btn-secondary" onclick="openImportModal()">Import from Sheets</button>

        <select class="filter-select" id="statusFilter" onchange="loadInventory()">
            <option value="">All Status</option>
            <option value="active">Unsold</option>
            <option value="posted">Posted</option>
            <option value="sold">Sold</option>
        </select>

        <select class="filter-select" id="batchFilter" onchange="loadInventory()">
            <option value="">All Batches</option>
            <option value="__none__">No batch (unassigned)</option>
        </select>

        <select class="filter-select" id="monthFilter" onchange="loadInventory()">
            <option value="">All Months</option>
            <option value="1">January</option>
            <option value="2">February</option>
            <option value="3">March</option>
            <option value="4">April</option>
            <option value="5">May</option>
            <option value="6">June</option>
            <option value="7">July</option>
            <option value="8">August</option>
            <option value="9">September</option>
            <option value="10">October</option>
            <option value="11">November</option>
            <option value="12">December</option>
        </select>

        <select class="filter-select" id="yearFilter" onchange="loadInventory()">
            <option value="">All Years</option>
            <option value="2026">2026</option>
            <option value="2025">2025</option>
            <option value="2024">2024</option>
            <option value="2023">2023</option>
        </select>

        <input type="text" class="search-input" placeholder="Search..." id="searchInput" oninput="debounceSearch()">

        <div style="display: flex; gap: 4px; margin-left: 16px;">
            <input type="text" class="search-input" placeholder="SKU to mark posted" id="markPostedSku" style="width: 160px; font-family: monospace;">
            <button class="btn btn-secondary btn-sm" onclick="markAsPosted()">Mark Posted</button>
        </div>

        <div class="spacer"></div>

        <span class="selection-info" id="selectionInfo"></span>
        <a href="#" id="selectAllLink" style="display:none; margin-right: 12px; font-size: 13px;" onclick="selectAllItems(event)">Select all <span id="selectAllCount">0</span> items</a>
        <button class="btn btn-secondary" id="batchBtn" style="display:none" onclick="openBatchAssignModal()">Assign to Batch</button>
        <button class="btn btn-danger" id="deleteBtn" style="display:none" onclick="deleteSelected()">Delete Selected</button>
    </div>

    <div class="table-container">
        <table id="inventoryTable">
            <thead>
                <tr>
                    <th class="cell-checkbox"><input type="checkbox" id="selectAll" onchange="toggleSelectAll()"></th>
                    <th class="sortable" onclick="sortTable('sku')">SKU</th>
                    <th class="sortable" onclick="sortTable('purchase_date')">Purchase Date</th>
                    <th class="sortable" onclick="sortTable('received_date')">Received Date</th>
                    <th class="sortable" onclick="sortTable('purchase_cost')">Cost</th>
                    <th class="sortable" onclick="sortTable('batch_name')">Product</th>
                    <th class="sortable" onclick="sortTable('batch_group')">Batch</th>
                    <th class="sortable" onclick="sortTable('sale_price')">Sale Price</th>
                    <th class="sortable" onclick="sortTable('profit')">Profit</th>
                    <th>VAT</th>
                    <th class="sortable" onclick="sortTable('sale_date')">Sale Date</th>
                    <th class="sortable" onclick="sortTable('days_to_sell')">Days</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody id="tableBody">
                <tr><td colspan="12" style="padding: 40px; text-align: center; color: #5f6368;">Loading...</td></tr>
            </tbody>
        </table>
    </div>

    <!-- Pagination -->
    <div class="pagination-bar">
        <div class="pagination-info">
            Showing <span id="showingFrom">0</span>-<span id="showingTo">0</span> of <span id="totalCount">0</span> items
        </div>
        <div class="pagination-controls">
            <button class="btn btn-sm btn-secondary" id="prevBtn" onclick="changePage(-1)" disabled>&larr; Prev</button>
            <span class="page-info">Page <span id="currentPage">1</span> of <span id="totalPages">1</span></span>
            <button class="btn btn-sm btn-secondary" id="nextBtn" onclick="changePage(1)">Next &rarr;</button>
        </div>
        <div class="per-page-select">
            <select id="perPageSelect" onchange="changePerPage()">
                <option value="50">50 per page</option>
                <option value="100" selected>100 per page</option>
                <option value="200">200 per page</option>
                <option value="500">500 per page</option>
            </select>
        </div>
    </div>

    <div class="summary-bar">
        <div class="summary-item">
            <span class="summary-label" id="filterLabel">All Items:</span>
            <span class="summary-value" id="totalItems">0</span>
        </div>
        <div class="summary-item" id="investmentItem">
            <span class="summary-label">Investment:</span>
            <span class="summary-value" id="totalInvestment">â‚¬0</span>
        </div>
        <div class="summary-item">
            <span class="summary-label">Revenue:</span>
            <span class="summary-value" id="totalRevenue">â‚¬0</span>
        </div>
        <div class="summary-item">
            <span class="summary-label">Profit:</span>
            <span class="summary-value positive" id="totalProfit">â‚¬0</span>
        </div>
        <div class="summary-item">
            <span class="summary-label">Avg Profit:</span>
            <span class="summary-value" id="avgProfit">â‚¬0</span>
        </div>
        <div class="summary-item">
            <span class="summary-label">Avg Days:</span>
            <span class="summary-value" id="avgDays">0</span>
        </div>
    </div>

    <!-- Bulk Add Modal -->
    <div class="modal-overlay" id="bulkAddModal">
        <div class="modal">
            <div class="modal-title">Add Batch</div>
            <div class="form-group">
                <label class="form-label">Assign to Batch Group</label>
                <select class="form-input" id="bulkBatchSelect" onchange="toggleBulkNewBatch()">
                    <option value="__new__">+ Create new batch group</option>
                </select>
            </div>
            <div class="form-group" id="newBulkBatchGroup">
                <label class="form-label">New Batch Group Name</label>
                <input type="text" class="form-input" id="bulkBatchGroupName" placeholder="e.g., dickies, levis lot">
            </div>
            <div class="form-group">
                <label class="form-label">Product Name (for individual items)</label>
                <input type="text" class="form-input" id="batchName" placeholder="e.g., dickies shirt, levis jeans">
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label class="form-label">Total Cost (â‚¬)</label>
                    <input type="number" class="form-input" id="totalCost" step="0.01" placeholder="700">
                </div>
                <div class="form-group">
                    <label class="form-label">Number of Items</label>
                    <input type="number" class="form-input" id="itemCount" placeholder="100">
                </div>
            </div>
            <div class="form-group">
                <label class="form-label">Cost per Item: <strong id="costPerItem">â‚¬0.00</strong></label>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label class="form-label">Purchase Date</label>
                    <input type="date" class="form-input" id="purchaseDate">
                </div>
                <div class="form-group">
                    <label class="form-label">Received Date</label>
                    <input type="date" class="form-input" id="receivedDate">
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeModal('bulkAddModal')">Cancel</button>
                <button class="btn btn-primary" onclick="submitBulkAdd()">Add Items</button>
            </div>
        </div>
    </div>

    <!-- Import Modal -->
    <div class="modal-overlay" id="importModal">
        <div class="modal">
            <div class="modal-title">Import from Google Sheets</div>
            <p style="color: #5f6368; margin-bottom: 16px; font-size: 14px;">
                Paste data from your Google Sheet (with or without header).<br>
                <strong>Auto-detects format. Supported columns:</strong><br>
                Purchase Date, Received Date, Cost, Product, Sale Price, Profit*, VAT, Sale Date, Days*<br>
                <span style="font-size: 12px;">* Profit and Days are skipped (calculated automatically)</span>
            </p>
            <div class="form-group">
                <label class="form-label">Assign to Batch (optional)</label>
                <select class="form-input" id="importBatchSelect" onchange="toggleImportNewBatch()">
                    <option value="">-- No batch (import without grouping) --</option>
                    <option value="__new__">+ Create new batch</option>
                </select>
            </div>
            <div class="form-group" id="importNewBatchGroup" style="display: none;">
                <label class="form-label">New Batch Name</label>
                <input type="text" class="form-input" id="importNewBatchName" placeholder="e.g., dickies, vintage lot">
            </div>
            <div class="form-group">
                <label class="form-label">Paste Data (Tab-separated)</label>
                <textarea class="form-input" id="importData" rows="10" placeholder="Select rows in Google Sheets, copy (Ctrl+C), and paste here..."></textarea>
            </div>
            <!-- Progress indicator -->
            <div id="importProgress" style="display: none; margin-bottom: 16px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 13px;">
                    <span id="importProgressText">Importing...</span>
                    <span id="importProgressCount">0 / 0</span>
                </div>
                <div style="background: #e0e0e0; border-radius: 4px; height: 8px; overflow: hidden;">
                    <div id="importProgressBar" style="background: #1a73e8; height: 100%; width: 0%; transition: width 0.1s;"></div>
                </div>
                <div id="importProgressDetails" style="font-size: 12px; color: #5f6368; margin-top: 6px;"></div>
            </div>
            <!-- Skipped rows log -->
            <div id="importErrorLog" style="display: none; margin-bottom: 16px;">
                <div style="font-size: 13px; font-weight: 500; color: #ea4335; margin-bottom: 8px;">Skipped Rows:</div>
                <div id="importErrorList" style="max-height: 150px; overflow-y: auto; font-size: 12px; background: #fce8e6; border-radius: 4px; padding: 8px; font-family: monospace;"></div>
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" id="importCancelBtn" onclick="closeModal('importModal')">Cancel</button>
                <button class="btn btn-primary" id="importBtn" onclick="importFromSheets()">Import</button>
            </div>
        </div>
    </div>

    <!-- Batch Assign Modal -->
    <div class="modal-overlay" id="batchAssignModal">
        <div class="modal">
            <div class="modal-title">Assign to Batch Group</div>
            <div class="form-group">
                <label class="form-label">Select existing batch or create new</label>
                <select class="form-input" id="batchSelectList" onchange="toggleNewBatch()">
                    <option value="">-- Select batch --</option>
                    <option value="__remove__" style="color: #ea4335;">Remove from batch</option>
                    <option value="__new__">+ Create new batch</option>
                </select>
            </div>
            <div class="form-group" id="newBatchGroup" style="display: none;">
                <label class="form-label">New Batch Name</label>
                <input type="text" class="form-input" id="newBatchName" placeholder="e.g., dickies, levis, vintage lot">
            </div>
            <p style="color: #5f6368; font-size: 13px; margin-top: 12px;" id="batchAssignInfo">
                <span id="batchAssignCount">0</span> items will be grouped into this batch.
                <br><small>Product names will not change.</small>
            </p>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeModal('batchAssignModal')">Cancel</button>
                <button class="btn btn-primary" id="batchAssignBtn" onclick="assignToBatch()">Assign</button>
            </div>
        </div>
    </div>

    <!-- Edit Product Modal -->
    <div class="modal-overlay" id="editProductModal">
        <div class="modal" style="max-width: 600px;">
            <div class="modal-title">Edit Product for Listing</div>
            <input type="hidden" id="editProductId">

            <div class="form-row">
                <div class="form-group" style="flex: 2;">
                    <label class="form-label">SKU</label>
                    <input type="text" class="form-input" id="editSku" readonly style="background: #f1f3f4; font-family: monospace;">
                </div>
                <div class="form-group" style="flex: 1;">
                    <label class="form-label">Status</label>
                    <select class="form-input" id="editStatus">
                        <option value="active">Active</option>
                        <option value="posted">Posted</option>
                        <option value="sold">Sold</option>
                        <option value="pending">Pending</option>
                        <option value="inactive">Inactive</option>
                    </select>
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">Title</label>
                <input type="text" class="form-input" id="editTitle" placeholder="Product title for listing">
            </div>

            <div class="form-group">
                <label class="form-label">Description</label>
                <textarea class="form-input" id="editDescription" rows="4" placeholder="Product description for listing..."></textarea>
            </div>

            <div class="form-row">
                <div class="form-group">
                    <label class="form-label">Category</label>
                    <input type="text" class="form-input" id="editCategory" placeholder="e.g., Shirts, Pants">
                </div>
                <div class="form-group">
                    <label class="form-label">Size</label>
                    <input type="text" class="form-input" id="editSize" placeholder="e.g., M, L, XL">
                </div>
            </div>

            <div class="form-row">
                <div class="form-group">
                    <label class="form-label">Condition</label>
                    <select class="form-input" id="editCondition">
                        <option value="">-- Select --</option>
                        <option value="new">New with tags</option>
                        <option value="like_new">Like new</option>
                        <option value="good">Good</option>
                        <option value="fair">Fair</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Color</label>
                    <input type="text" class="form-input" id="editColor" placeholder="e.g., Blue, Black">
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">Brand</label>
                <input type="text" class="form-input" id="editBrand" placeholder="e.g., Nike, Dickies">
            </div>

            <div class="form-group">
                <label class="form-label">Product Images</label>
                <div id="imagePreviewContainer" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 8px; min-height: 60px; background: #f8f9fa; border-radius: 8px; padding: 8px;">
                    <div style="color: #5f6368; font-size: 13px;">No images yet</div>
                </div>
                <div style="display: flex; gap: 8px;">
                    <input type="file" id="imageUpload" multiple accept="image/*" style="display: none;" onchange="handleImageUpload(this)">
                    <button type="button" class="btn btn-secondary" onclick="document.getElementById('imageUpload').click()" style="flex: 1;">
                        ðŸ“· Upload Images
                    </button>
                </div>
                <div id="uploadProgress" style="display: none; margin-top: 8px; color: #5f6368; font-size: 13px;">
                    Uploading...
                </div>
            </div>

            <div class="form-row">
                <div class="form-group">
                    <label class="form-label">Purchase Cost (â‚¬)</label>
                    <input type="number" class="form-input" id="editPurchaseCost" step="0.01">
                </div>
                <div class="form-group">
                    <label class="form-label">Sale Price (â‚¬)</label>
                    <input type="number" class="form-input" id="editSalePrice" step="0.01">
                </div>
            </div>

            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeModal('editProductModal')">Cancel</button>
                <button class="btn btn-primary" onclick="saveProductEdit()">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Cross-Post Modal -->
    <div class="modal-overlay" id="crossPostModal">
        <div class="modal" style="max-width: 500px;">
            <div class="modal-title">Post to Platforms</div>
            <input type="hidden" id="crossPostProductId">

            <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                <div style="font-weight: 500;" id="crossPostTitle">Product Title</div>
                <div style="font-size: 12px; color: #5f6368; font-family: monospace;" id="crossPostSku">SKU: RL-XXXXXXXX</div>
            </div>

            <div class="form-group">
                <label class="form-label">Select Platforms</label>
                <div style="display: flex; flex-direction: column; gap: 8px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="platformVinted" checked>
                        <span style="color: #09b1ba; font-weight: 500;">Vinted</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="platformMarktplaats" checked>
                        <span style="color: #f36d21; font-weight: 500;">Marktplaats</span>
                    </label>
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">Price (â‚¬)</label>
                <input type="number" class="form-input" id="crossPostPrice" step="0.01">
            </div>

            <div class="form-group">
                <label class="form-label">Description Preview</label>
                <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; font-size: 13px; max-height: 150px; overflow-y: auto; white-space: pre-wrap;" id="crossPostDescPreview">
                    Description will appear here with SKU appended...
                </div>
            </div>

            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeModal('crossPostModal')">Cancel</button>
                <button class="btn btn-primary" onclick="executePostToPlatforms()">Post to Selected Platforms</button>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
        let inventoryData = [];
        let selectedIds = new Set();
        let allItemsSelected = false;  // Track if ALL items across pages are selected
        let sortColumn = 'created_at';  // Default to created_at so newest items appear first
        let sortDirection = 'desc';
        let selectedCells = new Set(); // For math operations
        let currentPage = 1;
        let perPage = 100;
        let totalItems = 0;
        let totalPages = 1;
        let searchTimeout = null;
        let currentEditItem = null;  // For edit modal
        // Summary totals from API (for ALL items, not just current page)
        let summaryData = {
            investment: 0,
            revenue: 0,
            profit: 0,
            soldCount: 0
        };

        // Debounced search - waits 300ms after typing stops
        function debounceSearch() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                currentPage = 1;  // Reset to first page when searching
                loadInventory();
            }, 300);
        }

        // Format currency
        function formatCurrency(value) {
            if (value === null || value === undefined) return '';
            return new Intl.NumberFormat('nl-NL', {
                style: 'currency',
                currency: 'EUR'
            }).format(value);
        }

        // Format date for display
        function formatDate(dateStr) {
            if (!dateStr) return '';
            const d = new Date(dateStr);
            return d.toLocaleDateString('nl-NL');
        }

        // Format date for input
        function formatDateInput(dateStr) {
            if (!dateStr) return '';
            return dateStr.split('T')[0];
        }

        // Parse date from various formats
        function parseDate(dateStr) {
            if (!dateStr) return null;
            dateStr = dateStr.trim();

            // Handle DD.MM.YYYY format
            if (dateStr.includes('.')) {
                const parts = dateStr.split('.');
                if (parts.length === 3) {
                    return `${parts[2]}-${parts[1].padStart(2, '0')}-${parts[0].padStart(2, '0')}`;
                }
            }
            // Handle DD,MM,YYYY format (commas)
            if (dateStr.includes(',')) {
                const parts = dateStr.split(',');
                if (parts.length === 3) {
                    return `${parts[2].trim()}-${parts[1].trim().padStart(2, '0')}-${parts[0].trim().padStart(2, '0')}`;
                }
            }
            // Handle DD/MM/YYYY format
            if (dateStr.includes('/')) {
                const parts = dateStr.split('/');
                if (parts.length === 3) {
                    return `${parts[2]}-${parts[1].padStart(2, '0')}-${parts[0].padStart(2, '0')}`;
                }
            }
            return dateStr;
        }

        // Parse number (handles comma as decimal separator)
        function parseNumber(str) {
            if (!str || str === '') return null;
            return parseFloat(str.toString().replace(',', '.'));
        }

        // Show toast
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        // Mark item as posted by SKU
        async function markAsPosted() {
            const input = document.getElementById('markPostedSku');
            const sku = input.value.trim();

            if (!sku) {
                showToast('Enter a SKU first');
                return;
            }

            try {
                const response = await fetch(`/api/inventory/mark-posted/${encodeURIComponent(sku)}`, {
                    method: 'POST'
                });

                if (response.ok) {
                    const result = await response.json();
                    showToast(result.message);
                    input.value = '';  // Clear input
                    loadInventory();  // Refresh table
                } else {
                    const error = await response.json();
                    showToast(error.detail || 'Item not found');
                }
            } catch (error) {
                console.error('Error marking as posted:', error);
                showToast('Error marking as posted');
            }
        }

        // Load inventory data
        async function loadInventory() {
            // Preserve scroll position
            const container = document.querySelector('.table-container');
            const scrollPos = container?.scrollTop || 0;

            const status = document.getElementById('statusFilter').value;
            const batchId = document.getElementById('batchFilter').value;
            const search = document.getElementById('searchInput').value.trim();
            const monthFilter = document.getElementById('monthFilter').value;
            const yearFilter = document.getElementById('yearFilter').value;

            let url = `/api/inventory/items?page=${currentPage}&per_page=${perPage}`;
            url += `&sort_by=${sortColumn}&sort_dir=${sortDirection}`;
            if (status) url += `&status=${status}`;
            if (batchId === '__none__') {
                url += `&no_batch=true`;  // Filter for items without batch
            } else if (batchId) {
                url += `&batch_id=${batchId}`;
            }
            if (search) url += `&search=${encodeURIComponent(search)}`;
            if (monthFilter) url += `&sale_month=${monthFilter}`;
            if (yearFilter) url += `&sale_year=${yearFilter}`;

            try {
                const response = await fetch(url);
                const data = await response.json();

                inventoryData = data.items;
                totalItems = data.total;
                totalPages = data.total_pages;
                currentPage = data.page;

                // Store summary totals from API (for ALL items, not just current page)
                summaryData = {
                    investment: data.summary_investment,
                    revenue: data.summary_revenue,
                    profit: data.summary_profit,
                    soldCount: data.summary_sold_count
                };

                // Update pagination UI
                updatePagination();

                renderTable();  // This will call updateSummary
                loadBatchOptions();

                // Restore scroll position after render
                if (container) container.scrollTop = scrollPos;
            } catch (error) {
                console.error('Error loading inventory:', error);
                showToast('Error loading data');
            }
        }

        function updatePagination() {
            const from = totalItems === 0 ? 0 : (currentPage - 1) * perPage + 1;
            const to = Math.min(currentPage * perPage, totalItems);

            document.getElementById('showingFrom').textContent = from;
            document.getElementById('showingTo').textContent = to;
            document.getElementById('totalCount').textContent = totalItems;
            document.getElementById('currentPage').textContent = currentPage;
            document.getElementById('totalPages').textContent = totalPages;

            document.getElementById('prevBtn').disabled = currentPage <= 1;
            document.getElementById('nextBtn').disabled = currentPage >= totalPages;
        }

        function changePage(delta) {
            const newPage = currentPage + delta;
            if (newPage >= 1 && newPage <= totalPages) {
                currentPage = newPage;
                loadInventory();
            }
        }

        function changePerPage() {
            perPage = parseInt(document.getElementById('perPageSelect').value);
            currentPage = 1;  // Reset to first page
            loadInventory();
        }

        // Load batch options for filter (uses batch groups from API)
        async function loadBatchOptions() {
            const select = document.getElementById('batchFilter');
            const currentValue = select.value;

            try {
                const response = await fetch('/api/inventory/batch-groups');
                const batches = await response.json();
                select.innerHTML = '<option value="">All Batches</option>' +
                    `<option value="__none__" ${currentValue === '__none__' ? 'selected' : ''}>No batch (unassigned)</option>` +
                    batches.map(b => `<option value="${b.id}" ${b.id == currentValue ? 'selected' : ''}>${b.name}</option>`).join('');
            } catch (e) {
                console.error('Error loading batch groups:', e);
                // Keep existing options on error
            }
        }

        // Render table
        function renderTable() {
            const tbody = document.getElementById('tableBody');

            // Data is already searched, sorted, and filtered from server
            let filtered = inventoryData;

            if (filtered.length === 0) {
                tbody.innerHTML = '<tr><td colspan="12" style="padding: 40px; text-align: center; color: #5f6368;">No items found. Add items using the buttons above.</td></tr>';
                return;
            }

            tbody.innerHTML = filtered.map((item, idx) => {
                let rowClass = 'unsold';
                if (item.sale_date || item.status === 'sold') {
                    rowClass = 'sold';
                } else if (item.status === 'posted') {
                    rowClass = 'posted';
                }
                const profitClass = item.profit >= 0 ? 'positive' : 'negative';
                const isSelected = selectedIds.has(item.id);

                return `
                    <tr class="${rowClass} ${isSelected ? 'selected' : ''}" data-id="${item.id}">
                        <td class="cell-checkbox">
                            <input type="checkbox" ${isSelected ? 'checked' : ''} onchange="toggleSelect(${item.id})">
                        </td>
                        <td class="cell-sku" style="font-family: monospace; font-size: 11px; color: #5f6368;">${item.sku || '-'}</td>
                        <td><div class="cell cell-date" contenteditable="true" data-field="purchase_date" data-id="${item.id}" onblur="saveCell(this)" onmousedown="toggleCellSelection(this, event)">${formatDate(item.purchase_date)}</div></td>
                        <td><div class="cell cell-date" contenteditable="true" data-field="received_date" data-id="${item.id}" onblur="saveCell(this)" onmousedown="toggleCellSelection(this, event)">${formatDate(item.received_date)}</div></td>
                        <td><div class="cell cell-number" contenteditable="true" data-field="purchase_cost" data-id="${item.id}" onblur="saveCell(this)" onmousedown="toggleCellSelection(this, event)">${item.purchase_cost?.toFixed(2) || ''}</div></td>
                        <td><div class="cell" contenteditable="true" data-field="batch_name" data-id="${item.id}" onblur="saveCell(this)">${item.batch_name || ''}</div></td>
                        <td><div class="cell cell-batch" style="color: #1a73e8; font-size: 12px;">${item.batch_group || '-'}</div></td>
                        <td><div class="cell cell-number" contenteditable="true" data-field="sale_price" data-id="${item.id}" onblur="saveCell(this)" onmousedown="toggleCellSelection(this, event)">${item.sale_price?.toFixed(2) || ''}</div></td>
                        <td><div class="cell cell-number cell-profit ${profitClass}">${item.profit?.toFixed(2) || ''}</div></td>
                        <td><div class="cell cell-number" contenteditable="true" data-field="vat_amount" data-id="${item.id}" onblur="saveCell(this)" onmousedown="toggleCellSelection(this, event)">${item.vat_amount?.toFixed(2) || ''}</div></td>
                        <td><div class="cell cell-date" contenteditable="true" data-field="sale_date" data-id="${item.id}" onblur="saveCell(this)" onmousedown="toggleCellSelection(this, event)">${formatDate(item.sale_date)}</div></td>
                        <td><div class="cell cell-number">${item.days_to_sell !== null && item.days_to_sell !== undefined ? item.days_to_sell : ''}</div></td>
                        <td>
                            <div style="display: flex; gap: 4px;">
                                <button class="btn btn-secondary" style="padding: 4px 8px; font-size: 11px;" onclick="openEditModal(${item.id})">Edit</button>
                                <button class="btn btn-primary" style="padding: 4px 8px; font-size: 11px;" onclick="openCrossPostModal(${item.id})">Post</button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');

            // Update summary with filtered data
            updateSummary(filtered);
        }

        // Save cell on blur
        async function saveCell(cell) {
            const id = cell.dataset.id;
            const field = cell.dataset.field;
            let value = cell.textContent.trim();

            // Parse value based on field type
            if (field.includes('date')) {
                value = parseDate(value) || null;
            } else if (field.includes('cost') || field.includes('price') || field.includes('vat')) {
                value = parseNumber(value);
            }

            try {
                const response = await fetch(`/api/inventory/items/${id}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ [field]: value })
                });

                if (response.ok) {
                    const updated = await response.json();
                    // Update local data
                    const idx = inventoryData.findIndex(i => i.id == id);
                    if (idx !== -1) {
                        inventoryData[idx] = updated;
                    }
                    renderTable();  // This already calls updateSummary()
                } else {
                    showToast('Error saving');
                }
            } catch (error) {
                console.error('Error saving:', error);
                showToast('Error saving');
            }
        }

        // Update summary based on data (now using server-side summaries)
        function updateSummary(filteredData) {
            const data = filteredData || inventoryData;
            const monthFilter = document.getElementById('monthFilter').value;
            const yearFilter = document.getElementById('yearFilter').value;
            const isMonthYearFiltered = monthFilter || yearFilter;

            // Update filter label
            document.getElementById('filterLabel').textContent = isMonthYearFiltered ? 'Items Sold:' : 'Total Items:';

            // Hide investment when filtering by month (not relevant for sales view)
            document.getElementById('investmentItem').style.display = isMonthYearFiltered ? 'none' : 'flex';

            // Use API summary totals (now includes server-side month/year filtering)
            const displayItems = totalItems;
            const displayInvestment = summaryData.investment;
            const displayRevenue = summaryData.revenue;
            const displayProfit = summaryData.profit;
            const displaySoldCount = summaryData.soldCount;

            // Calculate averages
            const avgProfit = displaySoldCount > 0 ? displayProfit / displaySoldCount : 0;

            // For avg days, use data from current page
            const daysToSell = data.filter(i => i.sale_date && i.days_to_sell !== null && i.days_to_sell >= 0).map(i => i.days_to_sell);
            const avgDays = daysToSell.length > 0 ? daysToSell.reduce((a, b) => a + b, 0) / daysToSell.length : 0;

            document.getElementById('totalItems').textContent = displayItems;
            document.getElementById('totalInvestment').textContent = formatCurrency(displayInvestment);
            document.getElementById('totalRevenue').textContent = formatCurrency(displayRevenue);
            document.getElementById('totalProfit').textContent = formatCurrency(displayProfit);
            document.getElementById('totalProfit').className = 'summary-value ' + (displayProfit >= 0 ? 'positive' : 'negative');
            document.getElementById('avgProfit').textContent = formatCurrency(avgProfit);
            document.getElementById('avgProfit').className = 'summary-value ' + (avgProfit >= 0 ? 'positive' : 'negative');
            document.getElementById('avgDays').textContent = Math.round(avgDays) + ' days';
        }

        // Sort table (server-side)
        function sortTable(column) {
            if (sortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = column;
                sortDirection = 'desc';
            }

            // Update header classes
            document.querySelectorAll('th.sortable').forEach(th => {
                th.classList.remove('sorted-asc', 'sorted-desc');
            });
            const currentHeader = document.querySelector(`th[onclick="sortTable('${column}')"]`);
            if (currentHeader) {
                currentHeader.classList.add(sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
            }

            currentPage = 1;  // Reset to first page when sorting
            loadInventory();  // Reload from server with new sort
        }

        // Selection - optimized to not re-render entire table
        function toggleSelect(id) {
            if (selectedIds.has(id)) {
                selectedIds.delete(id);
                allItemsSelected = false;  // Deselecting clears "all items" mode
            } else {
                selectedIds.add(id);
            }
            updateSelectionUI();
            updateRowSelection(id);  // Just update the affected row, not entire table
        }

        function updateRowSelection(id) {
            const row = document.querySelector(`tr[data-id="${id}"]`);
            if (row) {
                const checkbox = row.querySelector('input[type="checkbox"]');
                if (selectedIds.has(id)) {
                    row.classList.add('selected');
                    if (checkbox) checkbox.checked = true;
                } else {
                    row.classList.remove('selected');
                    if (checkbox) checkbox.checked = false;
                }
            }
        }

        function toggleSelectAll() {
            const checked = document.getElementById('selectAll').checked;
            if (checked) {
                inventoryData.forEach(i => selectedIds.add(i.id));
            } else {
                selectedIds.clear();
                allItemsSelected = false;
            }
            updateSelectionUI();
            // Update all rows visually without full re-render
            document.querySelectorAll('#tableBody tr[data-id]').forEach(row => {
                const id = parseInt(row.dataset.id);
                const checkbox = row.querySelector('input[type="checkbox"]');
                if (selectedIds.has(id)) {
                    row.classList.add('selected');
                    if (checkbox) checkbox.checked = true;
                } else {
                    row.classList.remove('selected');
                    if (checkbox) checkbox.checked = false;
                }
            });
        }

        function updateSelectionUI() {
            const count = allItemsSelected ? totalItems : selectedIds.size;
            const allOnPageSelected = inventoryData.length > 0 && inventoryData.every(item => selectedIds.has(item.id));

            if (allItemsSelected) {
                document.getElementById('selectionInfo').textContent = `All ${totalItems} items selected`;
                document.getElementById('selectAllLink').style.display = 'none';
            } else if (count > 0) {
                document.getElementById('selectionInfo').textContent = `${count} selected`;
                // Show "select all" link only if all on current page are selected and there are more pages
                if (allOnPageSelected && totalItems > inventoryData.length) {
                    document.getElementById('selectAllLink').style.display = 'inline';
                    document.getElementById('selectAllCount').textContent = totalItems;
                } else {
                    document.getElementById('selectAllLink').style.display = 'none';
                }
            } else {
                document.getElementById('selectionInfo').textContent = '';
                document.getElementById('selectAllLink').style.display = 'none';
            }

            document.getElementById('deleteBtn').style.display = count > 0 ? 'inline-flex' : 'none';
            document.getElementById('batchBtn').style.display = count > 0 ? 'inline-flex' : 'none';
        }

        function selectAllItems(event) {
            event.preventDefault();
            allItemsSelected = true;
            // Also select all on current page visually
            inventoryData.forEach(item => selectedIds.add(item.id));
            updateSelectionUI();
            renderTable();
        }

        function clearAllSelection() {
            allItemsSelected = false;
            selectedIds.clear();
            updateSelectionUI();
            renderTable();
        }

        // Delete selected
        async function deleteSelected() {
            const count = allItemsSelected ? totalItems : selectedIds.size;
            if (!confirm(`Delete ${count} items? This cannot be undone.`)) return;

            let requestBody = {};

            if (allItemsSelected) {
                requestBody.all_items = true;
                const statusFilter = document.getElementById('statusFilter').value;
                const batchFilterVal = document.getElementById('batchFilter').value;
                if (statusFilter) requestBody.status_filter = statusFilter;
                if (batchFilterVal) requestBody.batch_filter = parseInt(batchFilterVal);
            } else {
                requestBody.item_ids = Array.from(selectedIds);
            }

            try {
                const response = await fetch('/api/inventory/items', {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                if (response.ok) {
                    const result = await response.json();
                    selectedIds.clear();
                    allItemsSelected = false;
                    updateSelectionUI();
                    showToast(result.message);
                    loadInventory();
                }
            } catch (error) {
                console.error('Error deleting:', error);
                showToast('Error deleting items');
            }
        }

        // Batch assignment functions
        async function openBatchAssignModal() {
            // Fetch all batch groups from API
            try {
                const response = await fetch('/api/inventory/batch-groups');
                const batches = await response.json();

                const select = document.getElementById('batchSelectList');
                select.innerHTML = '<option value="">-- Select batch --</option>' +
                    '<option value="__remove__" style="color: #ea4335;">Remove from batch</option>' +
                    '<option value="__new__">+ Create new batch</option>' +
                    batches.map(b => `<option value="${b.id}">${b.name}</option>`).join('');
            } catch (e) {
                console.error('Error loading batches:', e);
            }

            const count = allItemsSelected ? totalItems : selectedIds.size;
            document.getElementById('batchAssignCount').textContent = count;
            document.getElementById('newBatchGroup').style.display = 'none';
            document.getElementById('batchAssignModal').classList.add('active');
        }

        function toggleNewBatch() {
            const select = document.getElementById('batchSelectList');
            const isNew = select.value === '__new__';
            const isRemove = select.value === '__remove__';

            document.getElementById('newBatchGroup').style.display = isNew ? 'block' : 'none';

            // Update info text based on selection
            const info = document.getElementById('batchAssignInfo');
            const btn = document.getElementById('batchAssignBtn');
            const count = allItemsSelected ? totalItems : selectedIds.size;

            if (isRemove) {
                info.innerHTML = `<span style="color: #ea4335;">${count} items will be removed from their current batch.</span><br><small>Product names will not change.</small>`;
                btn.textContent = 'Remove from Batch';
                btn.className = 'btn btn-danger';
            } else {
                info.innerHTML = `<span id="batchAssignCount">${count}</span> items will be grouped into this batch.<br><small>Product names will not change.</small>`;
                btn.textContent = 'Assign';
                btn.className = 'btn btn-primary';
            }
        }

        async function assignToBatch() {
            const selectValue = document.getElementById('batchSelectList').value;
            let requestBody = {};

            if (selectValue === '__remove__') {
                // Remove from batch - set batch_id to null
                requestBody.remove_batch = true;
            } else if (selectValue === '__new__') {
                const batchName = document.getElementById('newBatchName').value.trim();
                if (!batchName) {
                    alert('Please enter a batch name');
                    return;
                }
                requestBody.batch_name = batchName;
            } else if (selectValue) {
                requestBody.batch_id = parseInt(selectValue);
            } else {
                alert('Please select or enter a batch name');
                return;
            }

            // Handle "all items selected" mode
            if (allItemsSelected) {
                requestBody.all_items = true;
                const statusFilter = document.getElementById('statusFilter').value;
                const batchFilterVal = document.getElementById('batchFilter').value;
                if (statusFilter) requestBody.status_filter = statusFilter;
                if (batchFilterVal) requestBody.batch_filter = parseInt(batchFilterVal);
            } else {
                requestBody.item_ids = [...selectedIds];
            }

            try {
                const response = await fetch('/api/inventory/items/assign-batch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                if (response.ok) {
                    const result = await response.json();
                    showToast(result.message);
                    selectedIds.clear();
                    allItemsSelected = false;
                    updateSelectionUI();
                    closeModal('batchAssignModal');
                    loadInventory();
                } else {
                    showToast('Error assigning batch');
                }
            } catch (error) {
                console.error('Error:', error);
                showToast('Error assigning batch');
            }
        }

        // Add single row
        async function addSingleRow() {
            try {
                const response = await fetch('/api/inventory/items', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        title: 'New Item',
                        purchase_cost: 0,
                        purchase_date: new Date().toISOString().split('T')[0]
                    })
                });

                if (response.ok) {
                    showToast('Row added');
                    loadInventory();
                }
            } catch (error) {
                console.error('Error adding row:', error);
            }
        }

        // Edit Product Modal functions
        function openEditModal(itemId) {
            const item = inventoryData.find(i => i.id === itemId);
            if (!item) {
                showToast('Item not found');
                return;
            }

            currentEditItem = item;
            document.getElementById('editProductId').value = item.id;
            document.getElementById('editSku').value = item.sku || '';
            document.getElementById('editStatus').value = item.status || 'active';
            document.getElementById('editTitle').value = item.title || '';
            document.getElementById('editDescription').value = item.description || '';
            document.getElementById('editCategory').value = item.category || '';
            document.getElementById('editSize').value = item.size || '';
            document.getElementById('editCondition').value = item.condition || '';
            document.getElementById('editColor').value = item.color || '';
            document.getElementById('editBrand').value = item.brand || '';
            document.getElementById('editPurchaseCost').value = item.purchase_cost || '';
            document.getElementById('editSalePrice').value = item.sale_price || '';

            // Show existing images
            renderImagePreviews(item.images || []);

            document.getElementById('editProductModal').classList.add('active');
        }

        function renderImagePreviews(images) {
            const container = document.getElementById('imagePreviewContainer');
            if (!images || images.length === 0) {
                container.innerHTML = '<div style="color: #5f6368; font-size: 13px;">No images yet</div>';
                return;
            }

            container.innerHTML = images.map((url, idx) => `
                <div style="position: relative; width: 80px; height: 80px;">
                    <img src="${url}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 4px; border: 1px solid #e0e0e0;">
                    <button onclick="deleteImage('${url}')" style="position: absolute; top: -6px; right: -6px; width: 20px; height: 20px; border-radius: 50%; background: #ea4335; color: white; border: none; cursor: pointer; font-size: 12px; line-height: 1;">Ã—</button>
                </div>
            `).join('');
        }

        async function handleImageUpload(input) {
            const files = input.files;
            if (!files || files.length === 0) return;

            const itemId = document.getElementById('editProductId').value;
            if (!itemId) {
                showToast('Please save the product first');
                return;
            }

            const formData = new FormData();
            for (let i = 0; i < files.length; i++) {
                formData.append('files', files[i]);
            }

            const progress = document.getElementById('uploadProgress');
            progress.style.display = 'block';
            progress.textContent = `Uploading ${files.length} image(s)...`;

            try {
                const response = await fetch(`/api/inventory/items/${itemId}/images`, {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    const result = await response.json();
                    showToast(`Uploaded ${result.uploaded.length} image(s)`);

                    // Refresh the current item data
                    const itemResponse = await fetch(`/api/inventory/items?page=1&per_page=1&search=${currentEditItem.sku}`);
                    const data = await itemResponse.json();
                    if (data.items && data.items.length > 0) {
                        currentEditItem = data.items[0];
                        renderImagePreviews(currentEditItem.images || []);
                    }
                } else {
                    const err = await response.json();
                    showToast('Upload failed: ' + (err.detail || 'Unknown error'));
                }
            } catch (error) {
                console.error('Upload error:', error);
                showToast('Upload failed');
            } finally {
                progress.style.display = 'none';
                input.value = '';  // Reset file input
            }
        }

        async function deleteImage(imageUrl) {
            const itemId = document.getElementById('editProductId').value;
            if (!confirm('Delete this image?')) return;

            try {
                const response = await fetch(`/api/inventory/items/${itemId}/images?image_url=${encodeURIComponent(imageUrl)}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    // Remove from current item and re-render
                    currentEditItem.images = (currentEditItem.images || []).filter(url => url !== imageUrl);
                    renderImagePreviews(currentEditItem.images);
                    showToast('Image deleted');
                } else {
                    showToast('Failed to delete image');
                }
            } catch (error) {
                console.error('Delete error:', error);
                showToast('Failed to delete image');
            }
        }

        async function saveProductEdit() {
            const itemId = document.getElementById('editProductId').value;

            const data = {
                title: document.getElementById('editTitle').value,
                description: document.getElementById('editDescription').value,
                status: document.getElementById('editStatus').value,
                category: document.getElementById('editCategory').value,
                size: document.getElementById('editSize').value,
                condition: document.getElementById('editCondition').value,
                color: document.getElementById('editColor').value,
                brand: document.getElementById('editBrand').value,
                // Images are handled separately via upload
                purchase_cost: parseFloat(document.getElementById('editPurchaseCost').value) || null,
                sale_price: parseFloat(document.getElementById('editSalePrice').value) || null
            };

            try {
                const response = await fetch(`/api/inventory/items/${itemId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });

                if (response.ok) {
                    closeModal('editProductModal');
                    showToast('Product updated');
                    loadInventory();
                } else {
                    const err = await response.json();
                    showToast('Error: ' + (err.detail || 'Failed to save'));
                }
            } catch (error) {
                console.error('Error saving product:', error);
                showToast('Error saving product');
            }
        }

        // Cross-Post Modal functions
        function openCrossPostModal(itemId) {
            const item = inventoryData.find(i => i.id === itemId);
            if (!item) {
                showToast('Item not found');
                return;
            }

            if (!item.title || !item.description) {
                showToast('Please edit the product first to add title and description');
                openEditModal(itemId);
                return;
            }

            currentEditItem = item;
            document.getElementById('crossPostProductId').value = item.id;
            document.getElementById('crossPostTitle').textContent = item.title;
            document.getElementById('crossPostSku').textContent = 'SKU: ' + (item.sku || 'N/A');
            document.getElementById('crossPostPrice').value = item.sale_price || item.purchase_cost || '';

            // Show description preview with SKU appended
            const descWithSku = (item.description || '') + '\n\n---\nSKU: ' + (item.sku || 'N/A');
            document.getElementById('crossPostDescPreview').textContent = descWithSku;

            document.getElementById('crossPostModal').classList.add('active');
        }

        async function executePostToPlatforms() {
            const itemId = document.getElementById('crossPostProductId').value;
            const price = parseFloat(document.getElementById('crossPostPrice').value);
            const postToVinted = document.getElementById('platformVinted').checked;
            const postToMarktplaats = document.getElementById('platformMarktplaats').checked;

            if (!postToVinted && !postToMarktplaats) {
                showToast('Please select at least one platform');
                return;
            }

            const platforms = [];
            if (postToVinted) platforms.push('vinted');
            if (postToMarktplaats) platforms.push('marktplaats');

            try {
                const response = await fetch(`/api/products/${itemId}/cross-post`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        platforms: platforms,
                        price: price
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    closeModal('crossPostModal');
                    showToast(`Posted to ${platforms.length} platform(s)`);
                    loadInventory();
                } else {
                    const err = await response.json();
                    showToast('Error: ' + (err.detail || 'Failed to post'));
                }
            } catch (error) {
                console.error('Error posting to platforms:', error);
                showToast('Error posting to platforms');
            }
        }

        // Modal functions
        async function openBulkAddModal() {
            // Load existing batches
            try {
                const response = await fetch('/api/inventory/batch-groups');
                const batches = await response.json();
                const select = document.getElementById('bulkBatchSelect');
                select.innerHTML = '<option value="__new__">+ Create new batch group</option>' +
                    batches.map(b => `<option value="${b.id}">${b.name}</option>`).join('');
            } catch (e) {
                console.error('Error loading batches:', e);
            }

            document.getElementById('bulkAddModal').classList.add('active');
            document.getElementById('purchaseDate').value = new Date().toISOString().split('T')[0];
            document.getElementById('newBulkBatchGroup').style.display = 'block';
        }

        function toggleBulkNewBatch() {
            const select = document.getElementById('bulkBatchSelect');
            const isNew = select.value === '__new__';
            document.getElementById('newBulkBatchGroup').style.display = isNew ? 'block' : 'none';
        }

        async function openImportModal() {
            // Load existing batches for the selector
            try {
                const response = await fetch('/api/inventory/batch-groups');
                const batches = await response.json();
                const select = document.getElementById('importBatchSelect');
                select.innerHTML = '<option value="">-- No batch (import without grouping) --</option>' +
                    '<option value="__new__">+ Create new batch</option>' +
                    batches.map(b => `<option value="${b.id}">${b.name}</option>`).join('');
            } catch (e) {
                console.error('Error loading batches:', e);
            }
            document.getElementById('importModal').classList.add('active');
        }

        function toggleImportNewBatch() {
            const select = document.getElementById('importBatchSelect');
            const isNew = select.value === '__new__';
            document.getElementById('importNewBatchGroup').style.display = isNew ? 'block' : 'none';
        }

        function closeModal(id) {
            document.getElementById(id).classList.remove('active');
        }

        // Calculate cost per item in bulk add modal
        document.getElementById('totalCost')?.addEventListener('input', updateCostPerItem);
        document.getElementById('itemCount')?.addEventListener('input', updateCostPerItem);

        function updateCostPerItem() {
            const total = parseFloat(document.getElementById('totalCost').value) || 0;
            const count = parseInt(document.getElementById('itemCount').value) || 1;
            const perItem = total / count;
            document.getElementById('costPerItem').textContent = formatCurrency(perItem);
        }

        // Submit bulk add
        async function submitBulkAdd() {
            const batchSelectValue = document.getElementById('bulkBatchSelect').value;
            const isNewBatch = batchSelectValue === '__new__';

            const data = {
                batch_name: document.getElementById('batchName').value,
                total_cost: parseFloat(document.getElementById('totalCost').value),
                item_count: parseInt(document.getElementById('itemCount').value),
                purchase_date: document.getElementById('purchaseDate').value || null,
                received_date: document.getElementById('receivedDate').value || null
            };

            // Handle batch group assignment
            if (isNewBatch) {
                const newBatchName = document.getElementById('bulkBatchGroupName').value.trim();
                if (!newBatchName) {
                    showToast('Please enter a batch group name');
                    return;
                }
                data.batch_group_name = newBatchName;
            } else {
                data.batch_id = parseInt(batchSelectValue);
            }

            if (!data.batch_name || !data.total_cost || !data.item_count) {
                showToast('Please fill all required fields');
                return;
            }

            try {
                const response = await fetch('/api/inventory/bulk-add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });

                if (response.ok) {
                    closeModal('bulkAddModal');
                    showToast(`Added ${data.item_count} items`);
                    loadInventory();
                    // Reset form
                    document.getElementById('batchName').value = '';
                    document.getElementById('bulkBatchGroupName').value = '';
                    document.getElementById('totalCost').value = '';
                    document.getElementById('itemCount').value = '';
                    document.getElementById('bulkBatchSelect').value = '__new__';
                    document.getElementById('newBulkBatchGroup').style.display = 'block';
                }
            } catch (error) {
                console.error('Error:', error);
                showToast('Error adding batch');
            }
        }

        // Import from sheets
        async function importFromSheets() {
            const data = document.getElementById('importData').value;
            if (!data.trim()) {
                showToast('Please paste data');
                return;
            }

            // Get batch selection
            const batchSelectValue = document.getElementById('importBatchSelect').value;
            let batchId = null;

            if (batchSelectValue === '__new__') {
                const newBatchName = document.getElementById('importNewBatchName').value.trim();
                if (!newBatchName) {
                    showToast('Please enter a batch name');
                    return;
                }
                // Create new batch first
                try {
                    const batchResponse = await fetch('/api/inventory/items/assign-batch', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ batch_name: newBatchName, item_ids: [] })
                    });
                    // The assign-batch endpoint creates the batch, but we need the ID
                    // Let's fetch batches to get the newly created one
                    const batchesResponse = await fetch('/api/inventory/batch-groups');
                    const batches = await batchesResponse.json();
                    const newBatch = batches.find(b => b.name === newBatchName);
                    if (newBatch) {
                        batchId = newBatch.id;
                    }
                } catch (e) {
                    console.error('Error creating batch:', e);
                    showToast('Error creating batch');
                    return;
                }
            } else if (batchSelectValue) {
                batchId = parseInt(batchSelectValue);
            }

            const lines = data.trim().split('\n');
            let imported = 0;
            let errors = 0;
            let errorDetails = [];

            // Show progress UI
            const progressDiv = document.getElementById('importProgress');
            const progressBar = document.getElementById('importProgressBar');
            const progressCount = document.getElementById('importProgressCount');
            const progressText = document.getElementById('importProgressText');
            const progressDetails = document.getElementById('importProgressDetails');
            const importBtn = document.getElementById('importBtn');
            const importData = document.getElementById('importData');

            progressDiv.style.display = 'block';
            importBtn.disabled = true;
            importBtn.textContent = 'Importing...';
            importData.disabled = true;

            // Detect format from header or first data row
            let formatB = false;
            const firstLine = lines[0].toLowerCase();
            if (firstLine.includes('durata') || firstLine.includes('article')) {
                formatB = true;
            }

            // Count actual data rows (excluding header)
            let startIndex = 0;
            if (lines[0].toLowerCase().includes('cand') || lines[0].toLowerCase().includes('date') ||
                lines[0].toLowerCase().includes('produs') || lines[0].toLowerCase().includes('article') ||
                lines[0].toLowerCase().includes('investitie')) {
                startIndex = 1;
            }
            const totalRows = lines.length - startIndex;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                // Skip header row if present
                if (i === 0 && (line.toLowerCase().includes('cand') || line.toLowerCase().includes('date') ||
                    line.toLowerCase().includes('produs') || line.toLowerCase().includes('article') ||
                    line.toLowerCase().includes('investitie'))) {
                    continue;
                }

                const currentRow = i - startIndex + 1;
                const percent = Math.round((currentRow / totalRows) * 100);
                progressBar.style.width = percent + '%';
                progressCount.textContent = `${currentRow} / ${totalRows}`;
                progressDetails.textContent = `Importing: ${line.split('\t')[3]?.substring(0, 30) || 'Item'}...`;

                const cols = line.split('\t');
                if (cols.length < 4) {
                    errors++;
                    const preview = cols.slice(0, 4).join(' | ') || '(empty row)';
                    errorDetails.push({
                        row: i + 1,
                        reason: 'Not enough columns (need at least 4)',
                        data: preview
                    });
                    continue;
                }

                let purchaseDate, receivedDate, purchaseCost, productName, salePrice, vatAmount, saleDate;

                // Detect format: check where the cost column is
                // Format A (9 cols): purchase_date, received_date (may be empty), cost, name, sale_price, profit, VAT, sale_date, days
                // Format B (8 cols): purchase_date, cost, name, sale_price, profit, VAT, sale_date, days
                const col1 = cols[1]?.trim() || '';
                const col2 = cols[2]?.trim() || '';

                // Check if col1 looks like a number (cost) - indicates Format B
                const col1IsNumber = col1 && (col1.includes(',') || /^\d+(\.\d+)?$/.test(col1));
                // Check if col2 looks like a number (cost) - indicates Format A
                const col2IsNumber = col2 && (col2.includes(',') || /^\d+(\.\d+)?$/.test(col2));

                // If col1 is empty or a date, and col2 is a number -> Format A
                // If col1 is a number -> Format B
                const isFormatA = !col1IsNumber && col2IsNumber;

                if (isFormatA) {
                    // Format A: purchase_date, received_date (may be empty), cost, name, sale_price, profit, VAT, sale_date, days
                    purchaseDate = parseDate(cols[0]);
                    receivedDate = parseDate(cols[1]) || parseDate(cols[0]); // Use purchase_date if received is empty
                    purchaseCost = parseNumber(cols[2]);
                    productName = cols[3]?.trim();
                    salePrice = parseNumber(cols[4]);
                    // cols[5] is profit - skip
                    vatAmount = parseNumber(cols[6]);
                    saleDate = parseDate(cols[7]);
                    // cols[8] is days - skip
                } else {
                    // Format B: purchase_date, cost, name, sale_price, profit, VAT, sale_date, days (NO received_date column)
                    purchaseDate = parseDate(cols[0]);
                    receivedDate = parseDate(cols[0]); // Same as purchase date
                    purchaseCost = parseNumber(cols[1]);
                    productName = cols[2]?.trim();
                    salePrice = parseNumber(cols[3]);
                    // cols[4] is profit - skip
                    vatAmount = parseNumber(cols[5]);
                    saleDate = parseDate(cols[6]);
                    // cols[7] is days - skip
                }

                if (!productName || purchaseCost === null) {
                    errors++;
                    const costCol = isFormatA ? cols[2] : cols[1];
                    const nameCol = isFormatA ? cols[3] : cols[2];
                    errorDetails.push({
                        row: i + 1,
                        reason: !productName ? 'Missing product name' : 'Missing or invalid purchase cost',
                        data: `${nameCol || '(no name)'} | Cost: ${costCol || '(empty)'} | Format: ${isFormatA ? 'A' : 'B'}`
                    });
                    continue;
                }

                const item = {
                    title: productName,
                    purchase_date: purchaseDate,
                    received_date: receivedDate,
                    purchase_cost: purchaseCost,
                    batch_name: productName,
                    sale_price: salePrice,
                    vat_amount: vatAmount,
                    sale_date: saleDate,
                    batch_id: batchId  // Assign to selected batch (null if none)
                };

                try {
                    const response = await fetch('/api/inventory/items', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(item)
                    });

                    if (response.ok) {
                        imported++;
                    } else {
                        errors++;
                        let errorReason = `HTTP ${response.status}`;
                        try {
                            const err = await response.json();
                            errorReason = err.detail || errorReason;
                        } catch (jsonErr) {
                            // Response wasn't JSON, try text
                            try {
                                errorReason = await response.text();
                            } catch (textErr) {}
                        }
                        errorDetails.push({
                            row: i + 1,
                            reason: errorReason.substring(0, 100),
                            data: `${productName} | ${purchaseCost}`
                        });
                    }
                } catch (e) {
                    errors++;
                    errorDetails.push({
                        row: i + 1,
                        reason: e.message,
                        data: `${productName} | ${purchaseCost}`
                    });
                }

                // Update progress text
                progressText.textContent = `Imported ${imported}${errors > 0 ? `, ${errors} errors` : ''}`;
            }

            // Complete
            progressBar.style.width = '100%';
            progressBar.style.background = errors > 0 ? '#fbbc04' : '#34a853';
            progressText.textContent = `Done! ${imported} imported${errors > 0 ? `, ${errors} skipped` : ''}`;
            progressDetails.textContent = '';

            // Show error log if there are errors
            const errorLogDiv = document.getElementById('importErrorLog');
            const errorListDiv = document.getElementById('importErrorList');

            if (errors > 0 && errorDetails.length > 0) {
                errorLogDiv.style.display = 'block';
                errorListDiv.innerHTML = errorDetails.map(err =>
                    `<div style="margin-bottom: 6px; padding-bottom: 6px; border-bottom: 1px solid #f5c6cb;">
                        <strong>Row ${err.row}:</strong> ${err.reason}<br>
                        <span style="color: #666;">Data: ${err.data}</span>
                    </div>`
                ).join('');

                // Keep modal open longer when there are errors
                importBtn.textContent = 'Close';
                importBtn.disabled = false;
                importBtn.onclick = () => {
                    closeModal('importModal');
                    resetImportUI();
                    loadInventory();
                };
            } else {
                // Auto-close on success
                setTimeout(() => {
                    closeModal('importModal');
                    resetImportUI();
                    showToast(`Imported ${imported} items`);
                    loadInventory();
                }, 1000);
            }
        }

        function resetImportUI() {
            const progressDiv = document.getElementById('importProgress');
            const progressBar = document.getElementById('importProgressBar');
            const importBtn = document.getElementById('importBtn');
            const importData = document.getElementById('importData');
            const errorLogDiv = document.getElementById('importErrorLog');

            progressDiv.style.display = 'none';
            progressBar.style.width = '0%';
            progressBar.style.background = '#1a73e8';
            importBtn.disabled = false;
            importBtn.textContent = 'Import';
            importBtn.onclick = importFromSheets;
            importData.disabled = false;
            importData.value = '';
            errorLogDiv.style.display = 'none';
            // Reset batch selector
            document.getElementById('importBatchSelect').value = '';
            document.getElementById('importNewBatchName').value = '';
            document.getElementById('importNewBatchGroup').style.display = 'none';
        }

        // ===== MATH OPERATIONS FOR CELLS =====

        function toggleCellSelection(cell, event) {
            // Only for number or date cells
            if (!cell.classList.contains('cell-number') && !cell.classList.contains('cell-date')) return;

            if (event.ctrlKey || event.metaKey) {
                event.preventDefault();
                event.stopPropagation();

                // Blur the cell to prevent editing mode
                cell.blur();
                window.getSelection().removeAllRanges();

                const cellKey = `${cell.dataset.id}-${cell.dataset.field}`;

                if (selectedCells.has(cellKey)) {
                    selectedCells.delete(cellKey);
                    cell.classList.remove('math-selected');
                } else {
                    selectedCells.add(cellKey);
                    cell.classList.add('math-selected');
                }

                updateMathToolbar();
                return false;
            }
        }

        function updateMathToolbar() {
            const toolbar = document.getElementById('mathToolbar');
            const countSpan = document.getElementById('mathSelectedCount');

            if (selectedCells.size > 0) {
                toolbar.classList.add('show');
                countSpan.textContent = `${selectedCells.size} cell${selectedCells.size > 1 ? 's' : ''} selected`;
            } else {
                toolbar.classList.remove('show');
            }
        }

        function clearCellSelection() {
            document.querySelectorAll('.cell.math-selected').forEach(cell => {
                cell.classList.remove('math-selected');
            });
            selectedCells.clear();
            updateMathToolbar();
        }

        async function applyMathOperation() {
            const expression = document.getElementById('mathExpression').value.trim();
            if (!expression) {
                showToast('Enter an expression like /5.1 or *0.2');
                return;
            }

            // Parse expression: operator + number
            const match = expression.match(/^([+\-*\/])(.+)$/);
            if (!match) {
                showToast('Invalid format. Use: /5.1, *0.2, +10, -5');
                return;
            }

            const operator = match[1];
            const operand = parseFloat(match[2].replace(',', '.'));

            if (isNaN(operand)) {
                showToast('Invalid number');
                return;
            }

            if (operator === '/' && operand === 0) {
                showToast('Cannot divide by zero');
                return;
            }

            let updated = 0;
            let errors = 0;

            for (const cellKey of selectedCells) {
                const [id, field] = cellKey.split('-');
                const cell = document.querySelector(`.cell[data-id="${id}"][data-field="${field}"]`);

                if (!cell) continue;

                const currentValue = parseFloat(cell.textContent.replace(',', '.')) || 0;
                let newValue;

                switch (operator) {
                    case '+': newValue = currentValue + operand; break;
                    case '-': newValue = currentValue - operand; break;
                    case '*': newValue = currentValue * operand; break;
                    case '/': newValue = currentValue / operand; break;
                }

                // Round to 2 decimal places
                newValue = Math.round(newValue * 100) / 100;

                try {
                    const response = await fetch(`/api/inventory/items/${id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ [field]: newValue })
                    });

                    if (response.ok) {
                        cell.textContent = newValue.toFixed(2);
                        updated++;
                    } else {
                        errors++;
                    }
                } catch (e) {
                    errors++;
                }
            }

            showToast(`Updated ${updated} cells${errors > 0 ? `, ${errors} errors` : ''}`);
            clearCellSelection();
            document.getElementById('mathExpression').value = '';

            // Reload to update computed values like profit
            loadInventory();
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            loadInventory();

            // Handle Enter key on math expression input
            document.getElementById('mathExpression').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    applyMathOperation();
                } else if (e.key === 'Escape') {
                    clearCellSelection();
                }
            });

            // Handle Escape to clear cell selection
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && selectedCells.size > 0) {
                    clearCellSelection();
                }
            });

            // Handle paste for selected cells
            document.addEventListener('paste', async (e) => {
                if (selectedCells.size === 0) return;

                // Don't intercept if focused on an input/textarea/contenteditable
                const activeEl = document.activeElement;
                if (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' ||
                    (activeEl.isContentEditable && !activeEl.classList.contains('math-selected'))) {
                    return;
                }

                e.preventDefault();

                const clipboardData = e.clipboardData.getData('text');

                // Handle both newline-separated (column copy) and tab-separated (row copy)
                // First split by newlines, then by tabs if needed
                let values = [];
                const lines = clipboardData.split(/[\n\r]+/);
                for (const line of lines) {
                    if (line.includes('\t')) {
                        // Row copy - split by tabs
                        values.push(...line.split('\t').map(v => v.trim()).filter(v => v));
                    } else if (line.trim()) {
                        values.push(line.trim());
                    }
                }

                if (values.length === 0) {
                    showToast('No values to paste');
                    return;
                }

                // Convert selectedCells Set to Array to maintain order
                const cellsArray = Array.from(selectedCells);

                if (values.length !== cellsArray.length) {
                    showToast(`${values.length} values, ${cellsArray.length} cells selected. Pasting what matches.`);
                }

                let updated = 0;
                let errors = 0;

                for (let i = 0; i < Math.min(values.length, cellsArray.length); i++) {
                    const cellKey = cellsArray[i];
                    const [id, field] = cellKey.split('-');
                    const cell = document.querySelector(`.cell[data-id="${id}"][data-field="${field}"]`);

                    if (!cell) continue;

                    let value = values[i];

                    // Parse value based on field type
                    if (cell.classList.contains('cell-number')) {
                        value = parseFloat(value.replace(',', '.'));
                        if (isNaN(value)) {
                            errors++;
                            continue;
                        }
                    } else if (cell.classList.contains('cell-date')) {
                        // Keep as string, backend will parse
                        value = value;
                    }

                    try {
                        const response = await fetch(`/api/inventory/items/${id}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ [field]: value })
                        });

                        if (response.ok) {
                            // Update cell display
                            if (cell.classList.contains('cell-number')) {
                                cell.textContent = value.toFixed(2);
                            } else {
                                cell.textContent = value;
                            }
                            updated++;
                        } else {
                            errors++;
                        }
                    } catch (e) {
                        errors++;
                    }
                }

                showToast(`Pasted ${updated} values${errors > 0 ? `, ${errors} errors` : ''}`);
                clearCellSelection();
                loadInventory();
            });

            // Handle Enter key on editable cells - save and move to next row
            document.getElementById('tableBody').addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && e.target.classList.contains('cell')) {
                    e.preventDefault();
                    e.target.blur(); // This triggers saveCell via onblur

                    // Optionally move to next row same column
                    const currentRow = e.target.closest('tr');
                    const nextRow = currentRow.nextElementSibling;
                    if (nextRow) {
                        const cellIndex = Array.from(currentRow.querySelectorAll('.cell')).indexOf(e.target);
                        const nextCell = nextRow.querySelectorAll('.cell')[cellIndex];
                        if (nextCell) {
                            nextCell.focus();
                        }
                    }
                }
                // Tab key - move to next cell
                if (e.key === 'Tab' && e.target.classList.contains('cell')) {
                    e.preventDefault();
                    e.target.blur();

                    const cells = Array.from(document.querySelectorAll('.cell[contenteditable="true"]'));
                    const currentIndex = cells.indexOf(e.target);
                    const nextIndex = e.shiftKey ? currentIndex - 1 : currentIndex + 1;
                    if (cells[nextIndex]) {
                        cells[nextIndex].focus();
                    }
                }
                // Escape - cancel editing
                if (e.key === 'Escape' && e.target.classList.contains('cell')) {
                    e.target.blur();
                    loadInventory(); // Reload to discard changes
                }
            });
        });

        // Close modal on outside click
        document.querySelectorAll('.modal-overlay').forEach(overlay => {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    overlay.classList.remove('active');
                }
            });
        });
    </script>
</body>
</html>
